/*
let userName;
userName = prompt("Privet, kak tebya zovyt?", "imya");
alert( `privet ${userName}`);
alert(typeof (userName));





let numberData1;
let numberData2;
numberData1 = 1;
numberData2 = 0;
alert( numberData1/numberData2);

//ПРИМИТИВНЫЕ ТИПЫ ДАННЫХ
let varData;
varData = 1; // числа
varData = 1.01;
varData = 11n; // BigInt
varData = "строка"; // двойные кавычки , данные строка
varData = 'строка'; // одинарные кавычки, данные строка
varData = `строка ${name}`; // обратные одинарные кавычки, данные строка
varData = true; // булевые тип данных, логический
varData = false; // булевый тип данных, логический
varData = null; // ничего, пусто, значение не известно
alert(varData); //undefined! обозначает что значение не было присвоено!
//null- используется для присвоения переменной пустого значения
//undefined- используется для проверки, была ли переменная НАЗНАЧЕНА

typeof(varData); // возвращает тип элемента
*/
/*
// функции интерфейса
// alert, prompt, confirm

alert("hello");
//
let userName;
userName = prompt("Введи свое имя:", "имя");
alert(`твое имя - ${userName}!`);

// 
let ageCheck;
ageCheck = confirm("Тебе больше 18+?");
if (ageCheck) {
	alert("добро пожаловать!");
}
else {
	alert("всего доброго!");
}


let userName;
userName = prompt("Привет, как тебя зовут?","твое имя");
alert(`Привет, ${userName}!`);

*/
// СТРОКОВОЕ ПРЕОБРАЗОВАНИЕ:
// alert - приводит значение к строке
// String(value); - точно и явно приводит значение к строке
/*
let valueData_1;
let valueData_2;
let valueData_3;
valueData_1 = 2;
valueData_2 = 3;

alert(valueData_3 = 3);
alert(typeof(valueData_3));
*/

// ЧИСЛЕННОЕ ПРЕОБРАЗОВАНИЕ:
// преобразование происходит либо в математических выражениях при помощи математических операторов
// либо происходит в математических функциях, например точно и явно Number(value);

//alert( "6" / "2" );

//let numberValue;
//let numberValueChange;
//numberValue = "666"
//alert(typeof(numberValue));
//numberValueChange = Number(numberValue);
//alert(typeof(numberValueChange));

//alert(Number(123n));

//ЛОГИЧЕСКОЕ ПРЕОБРАЗОВАНИЕ:
//логическое преобразование происходит в логических операциях
//точно и явно Boolean(value) приводит к логическому типу
/*"use strict";
let userValues;
userValues = prompt("Тебе больше +18?","введи свой возраст");
userValues = Number(userValues);
if (userValues) {
	alert( `Если вычесть из 100 твой возраст, то получится: ${100-userValues}`)
}
else {
	alert("Ты не ввел значение возраста!")
} */

// математические операторы - приводят значение к числовому значению или NaN


// БАЗОВЫЕ ОПЕРАТОРЫ, МАТЕМАТИКА
/*
операнд(аргумент) - то к чему применяется оператор
унарный - унарный оператор, оператор который применяется к одному операнду(аргументу)
бинарный - бинарный оператор, оператор который применяются к двум операндам(имеет два аргумента)

МАТЕМАТИКА:
Сложение +
Вычитание - 
Умножение *
Деление /
Взятие остатка от деления %
Введение в степень **

let numberValue1;
let numberValue2;
let numberValue
numberValue1 = 1;
numberValue2 = 2;
numberValue = numberValue2 - numberValue1;
alert(numberValue);

// ВЗЯТИЕ ОСТАТКА ОТ ДЕЛЕНИЯ %   :
let numberValue1;
let numberValue2;
numberValue1 = 14.13;
numberValue2 = 3;
alert(numberValue1 % numberValue2);
*/
// ВОЗВЕДЕНИЕ В СТЕПЕНЬ **  :
/*
let numberValue1;
let numberValue2;
let numberValue;

numberValue1 = 16;
numberValue2 = 1/2;

numberValue = numberValue1 ** numberValue2;

alert (numberValue);
*/

// СЛОЖЕНИЕ СТРОК ПРИ ПОМОЩИ БИНАРНОГО ПЛЮСА +
// ТОЛЬКО БИНАРНЫЙ ПЛЮС ПРЕОБРАЗУЕТ ЧИСЛА С СТРОКАМ, ЕСЛИ ВСТРЕЧАЕТ СТРОКУ ТО НАЧИНАЕТ ЧИСЛА
// ПРИВОДИТЬ К СТРОКЕ, ДРУГИЕ МАТЕМАТИЧЕСКИЕ ОПЕРАТОРЫ ПРИВОДЯТ ЗНАЧЕНИЯ К ЧИСЛАМ
/*let stringData;
stringData = "1" - 2 - 2;
alert(stringData);
*/
// УНАРНЫЙ ПЛЮС +, ПРИМЕНЯЮТСЯ К ОДНОМУ ОПЕРАНДУ(АРГУМЕНТУ)
// преобразует не числовые значение в числа, а числа оставляет числами
/*
let numberData1;
let numberData2;
let numberDemo;

numberDemo = -2;
alert(+numberDemo);
numberDemo = 1;
alert(+numberDemo);

numberValue1 = true;
alert(+numberValue1);
numberValue2 = "";
alert(+numberValue2);
*/
/*let apple;
let orange;
apple = "2";
orange = "3"
alert( +apple + +orange);
*/

// ПРИОРИТЕТЫ ОПЕРАТОРОВ:
// приоритет это порядок выполянения операторов
// также приоритет(порядок) выполнения операторов
// может определяться скобками
// каждый оператор имеет номер приоритета
// операторы выполняются слева направо, при равном приоритете
// чем больше приоритет тем быстрее выполнится оператор

// ПРИСВАИВАНИЕ :
// оператор присваивания "=" имеет один из самых низких приоритетов
// вначале выполняется вся арифметика, потом оператор присваинвания "="
// оператор присваивания возвращает значение
// присваивание по цепочке, цепочка присваивания
// Сокращённая арифметика с присваиванием
// если нужно применить оператор к переменной и сохранить результат
// в ней же, то используется сокращенная арифметика
// ИНКЕРЕМЕНТ И ДЕКРЕМЕНТ
// постфиксный инкеремент увеличивает переменную на единицу variable++
// постфиксный декремент уменьшает переменную на единицу variable--
// инкремент и декремент можно применить только к ПЕРЕМЕННОЙ
// префиксный инкремент (++counter) и прекфиксный декремент (--counter)
// используются чтобы сразу присвоить и получить новое значение
// префиксный инкремент и декремент нужны если допустим нужно
// сразу вывести значение ( alert(++counter)), или допустим
// сразу использовать полученное значение в выражении

// ПОБИТОВЫЕ ОПЕРАТОРЫ
// побитовые операторы работают с 32-битными числами
// либо приводят числа к 32-битному виду и потом работают с ними
//
//AND(&)И
//OR(|)ИЛИ
//XOR(^)ИСКЛЮЧАЮЩЕЕ ИЛИ
//NOR(~)НЕ
//LEFT SHIFT (<<) ЛЕВЫЙ СДВИГ
//RIGHT SHIFT (>>) ПРАВЫЙ СДВИГ
//ZERO-FILL RIGHT SHIFT (>>>) ПРАВЫЙ СДВИГ С ЗАПОЛНЕНИЕМ НУЛЯМИ


// ОПЕРАТОР ЗАПЯТАЯ ","
// используется для написания более короткого кода,
// предоставляет возможность записать  несколько выражений, разделяя их запятой
// каждое выражение выполняется, но возвращает результат только последнего
// выражения с запятой нужно записывать в скобках


// ОПЕРАТОРЫ СРАВНЕНИЯ:
// больше/меньше      a > b  /  a < b
// больше или равно/меньше или равно      a>=b / a<=b
// равно   a == b
// не равно a != b
// операторы сравнения возвращают значения логического типа
// сравнение строк, используется алфавитные(лексиграфический) порядок
// строки сравниваются посимвольно
// то есть берется первая пара символов и сравниваются по номеру позциии в таблице utf-8
// потом вторая пара сравниваемы символов и так далее
// Сравнение разных типов данных
// при сравнении разных типов язык приводит такие данные к числу
// строгое сравнение  a === b
// строго сравнение  проверяет равенство данных без приведения типов к одному типу
// также есть оператор строго неравенства a !== b
// сравнение null и undefined



// УСЛОВНОЕ ДЕЛЕНИЕ IF, ? 
/*

if(true) {
	выполнить этот код; // этот код выполняется если аргумент if дает Правду
}
else {
	выполнить тогда этот код; // этот код выполняется если аргумент if дал Неправду
}
инструкция if(true) преобразует выражение в скобках 
код:
if(0) {
	//code    -такой код никогда не выполнится
}


if(1) {
	//code    -такой код выполнится всегда
}

можно передать заранее вычисленное логическое значение:
let year;
year = prompt("Введите год выхода спецификации:","");
let condition = (year==2015);
if (condition) {
	//code
}

необязательный блок Else
else - выполняется когда условия выражения if() ложно

if(0) {
	
}
else {
	alert("в этом коде всегда будет ложен аргумент if()")
}


несколько условий else if

если выражение при if неверно, то 
это выражение можно проверить на соответствие true
конструкцией else if
*/


/* ЗАПИСАТЬ ЗНАКОМ ВОПРОСА
let permitionAge;

permitionAge = prompt("Введите ваш возраст, мы подберем категорию фильмов:","возраст");

if ( (permitionAge < 18) & (permitionAge >= 1)) {
	alert(`Ваш возраст: ${permitionAge} лет, для вас есть категория Детских Фильмов`);
}
else if ( (permitionAge >= 18) & (permitionAge < 50)) {
	alert(`Ваш возраст: ${permitionAge} лет, для вас есть категория Взрослых Фильмов`);
}
else if (permitionAge >= 50) {
	alert(`Ваш возраст: ${permitionAge} лет, для вас есть категория СССР фильмов`);
}
else {
	alert("вы ввели неправильный данные!");
}

*//*
let permitionAge;
let message;
permitionAge = prompt("Введите ваш возраст, мы подберем категорию фильмов:","возраст");
message = 
	((permitionAge < 18) & (permitionAge >= 1))?
(`Ваш возраст: ${permitionAge} лет, для вас есть категория Детских Фильмов`):
	( (permitionAge >= 18) & (permitionAge < 50))?
(`Ваш возраст: ${permitionAge} лет, для вас есть категория Взрослых Фильмов`):
	(permitionAge >= 50)?
(`Ваш возраст: ${permitionAge} лет, для вас есть категория СССР фильмов`):
("вы ввели неправильный данные!");
alert(message);


*//*

let question;

question = prompt("Какое официальное название JavaScript?","");
if (question == "ECMASCRIPT") {
	alert(`Верно это - ${question}`);
}
else {
	alert(`${question} - неправильный ответ!`);




*//*


let numberValue;
numberValue = prompt("Введите числовое значение:","число");
if(numberValue == null) {
	alert("error");
}
else if(numberValue > 0) {
	alert(1);
}
else if (numberValue < 0) {
	alert(-1);
}
else {
	numberValue = Number(numberValue);
}

if ( numberValue === 0) {
	alert(0);
}
else  {
	alert("не число!");
}

*//*

let result;
let a;
let b;
a = prompt("vvedite znachenie A","a");
a = Number(a);
b = prompt("vvedite znachenie B","b");
b = Number(b);
result = (a + b < 4)?"malo":"mnogo";
alert(result);









*//*


let message;
let login;
login = prompt("Введите логин:","логин");
message = (login == "Сотрудник")?`Привет, ${login}`:(login == "Директор")?`Здравствуйте, ${login}`:(login == '')?"Нет логина":"";
alert(message);

*/


/*
Логические операторы:
И - &&
ИЛИ - ||
НЕ - !
оператор нулевого слияния - ??


оператор ИЛИ ||  :
	возможные комбинации оператора ИЛИ (таблица истинности)
	alert(true||true); //true
	alert(false||true); //true
	alert(true||false); //true
	alert(false||false);//false

	если хотя бы один аргумент(операнд) оператора ИЛИ равен TRUE то такое выражение возвращает TRUE


result = a||b;
оператор ИЛИ || возвращает  первое истинное значение, или последнее если нет истинного
	способы использования оператора ИЛИ:
	1) получение первого истинного значения  из списка переменных или выражений
	2) сокращенное вычисление
	3)
*//*

let message;
message = prompt("как называется спецификация JavaScript","название спецификации");
if ((message == "ECMAScript")||(message == "EcmaScript")||(message == "ECMASCRIPT")) {
	alert(`Правильно! Название спецификации - ${message}`);
}
else {
	alert(`Неправильно! ${message} - это неправильный ответ!`);
}



*//*
логический оператор И &&
оператор И && возвращает TRUE когда все операнды(аргументы) равны TRUE
таблица истинности оператора И &&:
alert(true&&true); //true
alert(false&&true); //false
alert(true&&false); //false
alert(false%%false); //false

Оператор И && находит первое ложное значение
если оператор И находит значение false в списке значений, то останавливает выполнения ряда выражений
и возвращает  исходное значение этого операнда
если все операнды(аргументы) были истинными, то возвращает последний


оператор НЕ !
1) приводит к логическому значение свой аргумент
2) затем возвращает противоположное логическое значение аргумента
оператор двойного НЕ !! используют для привидения выражения к логическому типу

let husband_gender;
let wife_gender;
husband_gender = prompt("Введите пол мужа: ","пол");
wife_gender = prompt("Введите пол жены: ","пол");
if (husband_gender == "мужской" && wife_gender == "женский") {
	alert(`Все праивльно! Пол мужа -${husband_gender}, пол жены -${wife_gender}`);
}
else {
	alert("неправильно! :<");
}



let data;
let exp;
data = false;
exp = prompt("Введите ваше сообщение:","");
if (!data) {
	alert(`Ваше сообщение -${exp}`);
}

let check;
check = alert(1);
alert(check);



let age;
age = prompt("Введите ваш возраст: ","");
if ((!(age>=14))||(!(age<=90))) {
	alert(`Отлично, у вас есть доступ к сайту вам - ${age} лет`);
}
else {
	alert(`У вас нет доступа к сайту! Вам ${age} лет`);
}


let age;
age = prompt("Введите ваш возраст: ","");
if ((age<14)||(age>90)) {
	alert(`Отлично, у вас есть доступ к сайту вам - ${age} лет`);
}
else {
	alert(`У вас нет доступа к сайту! Вам ${age} лет`);
}



let login;
let password;

login = prompt("Введите ваш логин:","логин");
if ( login == "Админ") {
	password = prompt("Введите ваш пароль:","пароль");
	password = 
	(password = "Яглавный")
		?alert(`Здравствуйте! ${login}`)
			:(password="null")
				?alert("Отменено")
					:(password != "Яглавный")
						?alert("Неверный пароль!")
							:"";	
}
else if ( login !== "Админ") {
	alert("я Вас не знаю!");
}
else {
	alert("Отменено");
}



Оператор нулевого слияние ??
возвращает аргумент если он определен
результат вычисления выражения  A??B будет следующим:
если A определено, то А
если A не определено, то B

оператор ?? возвращает первый аргумент(операнд) который не null/undefined, иначе второй

разница между оператором нулевого слияния ?? и оператором ИЛИ ||
|| возвращает первое истинное значение
?? возвращает первое определенное значение

использование  оператора ?? вместе с операторами И &&  ИЛИ|| без скобок ЗАПРЕЩЕНО
потому что у этих операторов одинаковые приоритеты!


Циклы while и цикл for
ЦИКЛ WHILE
while(condition) {
	//код
	//также это наызвается "тело цикла"
}
код "тело цикла" выполняется пока condition- истинно
одно выполнение цикла называется итерация




ЦИКЛ DO... WHilE
do {
	//тело цикла
} while(condition);
в данном случае цикл вначале выполнит тело цикла,
а потом проверит условие condition

Цикл for
for(начало;условие;шаг) {
	//... тело цикла ...
}
порядок выполнения цикла for:
1) начало - выполняется один раз при входе в цикл
2) условие - проверяется перед каждой итерацией цикла, если становится равным false, то останавливается
3) тело - выполняется снова и снова пока условие равно true
4) шаг - выполняется после тела цикла на каждой итерации перед проверки условия


for (let i=...; ...; ...) {
	//...
}
а данном случае let i объявляет переменную внутри цикла
эта переменная существует только внутри цикла

пропуск частей цикла for
любая часть цикла for может быть пропущена

for(;;) {
	такой цикл будет выполняться вечно
}

прерывание цикла 
специальная директива break
позволяет выйти из цикла в любой момент


директива continue
при выполнение этой директивы пропускается шаг цикла
цикл переходит к следующей итерации


нельзя использовать директивик break или coninue справа от тернарного оператора ?


работа директивы break с меткой
чтобы выйти сразу из нескольких уровней вложения цикла
используется break с меткой
метка имеет вид:

labelName: for(...,...,...) {
	...
	if() break labelName;
}



работа директивы continue с меткой
скорее всего если условие при директиве continue равно true,
то выполнение скрипта пропускается до отметки labelName
метка имеет вид:
labelName: for(;;) {
	if() continue labelName;
}


метки не позволяют прыгнуть куда угодно в коде
директивы break и continue должны находится внутри блока кода
эти директивы должны находится внутри Маркированного блока кода,
для того чтобы использовать метку


Конструкция SWITCH
конструкция switch заменяет собой несколько if
синтаксис:
swich(x) {
   case 'value1':
	...
	[break]
   case 'value2':
	...
	[break]

   defaut:
	...
	[break]
}	
конструкция switch имеет один или несколько блоков case
и необязательный блок default
Принцип Действия:
Переменная x проверяется на строгое равенство
значению 'value1', затем второму 'value2' и так далее..
Если соответсвие установлено - switch начинает выполнять
соответсвующие директивы case и далее до ближайщего break
(или до конца switch)
Если ни один case не совпал - выполняется директива
default(если есть)

любое выражение может быть 
аргументом switch\case

группировка дериктив case

тип имеет значение,
проверка на равенство всегда строгая,
значения должны быть одного типа, чтобы выполнилось равенство


Функции:
для создания функции требуется ее объявление
function имя_функции(параметры_функции) {
	код_функции
}


Локальные переменные на уровне функций:
переменные объявленные внутри функций , видны только внутри этой функции

Внешние переменные(глобальные переменные)
у функций есть полный доступ к внешним переменным
функции могут читать и перезаписывать внешние переменные(глобальные переменные)

параметры функции
параметр - это переменная, указанная в круглых скобках в объявлении функции
аргумент - это значение(копия) которое передается фукнции при ее вызове


значения по умолчанию:
function имя_функции(параметр="значение по умолчанию"){
	код функции
}
по умолчанию можно добавить не только статичные данные вроде строки
но можно укажать выражение или другую функцию

Возврат значения функции return
в данном примере функция выполняется до директивы return
функция останавливается и значение возвращается   в вызвавший ее код
присваивается перменой result

нельзя добавлять перенос строки между return и его значением

function sum(a, b) {
	return a+b;
}

let result = sum(1, 2);
alert(result);


пример  Function Declaration:
function имя_фукнции() {
	код_функции;
}

пример Function Expression:
let имя_функции = function() {
	код функции;
}

Function Expression позволяет создавать новую ф-цию
в середине любого выражения

функция это значение
ее ожно скопировать в другую переменную
имя_фукнции есть перменная
имя_функции - содержит данные о ф-ции
имя_фкнкции() - возвращает результат работы кода ф-ции
в Function Expression ставиться точка с запятов в конце функции
а в Function Declaration точка с запятой не ставится

функции-колбеки
идея в том что мы передаем функцию и ожидаем что она выховется обратно

анонимные функции
функции у которых не имен называются анонимными



Сравнение Function Expression с Function Declaration
function declaration 
	объявляется отдельно конструкцией function имя_функции(...) {}

function expression
	функция создается внутри другого выражекния 
	let имя_функции_переменной = function() {}


Когда создается функция движком JavaScript:
Function Expression создаётся, когда выполнение когда доходит до данной ф-ции
а затем уже можно использовать данную ф-цию

Function Declaration создаёт ф-цию заранее на стадии ИНИЦИАЛИЗАЦИИ кода
в таком случае ф-ция может быть вызвана раньше чем она объявлена в коде

Function Declaration
особенность заключается в Блочной Области видимости
в строгом режиме 
когда function declaration находится в блоке кода {...}
функция доступна внутри данного блока кода но не снаружи его

Стрелочный Функции
основы стрелочных функций
стрелочная функция это сокращеная форма записи Function Expression
пример сокращения:

let func = function(arg1, arg2,... argN) {
	return expression;
}
сокращение до стрелочного вида
let func = (arg1, arg2,... argN) => expression;


многострочные стрелочные функции

let sum = (a, b) => {
	код тело фукнции
	return.. //обязательно указывать директиву return в многострочных стрелочных ф-цияъ
}


Объекты

объекты это сложный тип данных, так как
хранит коллекции простых данных

объект содержит:
фигурные скобки {}
фигруные скобки содержат список(коллекцию) свойств
свойство - это пара вида - Ключ:Значение
Ключ- строка(имя свойства)
Значению- может быть чем угодно!

синтаксис объектов:
let user = new Object(); // синтактсис Конструктор Объекта
let user = {}; //синтаксис Литерал Объекта, имя объекта- user

let user = {        // начало , литерал объекта user
	name: "John",   // под ключом name хранится значение John
	age: 30,       // под ключом age хранится значение 30
};

let имя_объекта = {
	имя_свойства1= значение_свойтсва1(данные),
	имя_свойства2= значение_свойства2(данные),
}
для получения данных из объекта используем этот синтаксис
alert( имя_объекта.имя_свойства1);

в любой момент можно добавить в объект новые свойства,
удалить старые, или прочитать имеющиеся свойства, а также присвоить данные св-ву
значение свойства может быть любого типа!

для удаления св-ва объекта используется оператор delete

delete имя_объекта.имя_свойтсва1

имя свойства объекта состоящее из нескольких слов
должно быть объявлено в кавычках ""
let имя_объекта = {
	"имя свойства1 объекта": значение,
};

последнее свойство в объекте заканчивается запятой ,
, - висячая запятая

если объявить объект константой
const name_obj = {
	name: "peter",
}

name_obj.name = "carla";
alert(name_obj.name);
то код не выдаст ошибки потому что изменилось содержание объекта
а не переменная name_obj

данные(значение) записанные в объект при помощи ключа из двух слов в кавычках
можно запросить только через квардратные скобки без точки
имя_объект[имя_свойства1]

[] квадратные скобки позволяют обратиться
к имени свойства которое содержится в переменной:
let key = "likes birdsn"
user.[key] = true;

пример: 
let user_data = {
	name: "Ashley",
	age: 33,
	gender: "female",
	"eye color": "green",
	height: "180cm",
}
let key = prompt("What you want Know about Ashley?","");
alert(user_data[key]);


вычисляемые свойства


свойство переменной
можно использовать существующие перменные
как значение для свойств объекта с тем же именем

если имя свойства совспадает с названиями перменных в значении свойства
то можн сократить такую запись, пример
let user = {
	name: name,
	password: password,
}

let user = {
	name,
	password,
}

для имен свойств
не сущетсвует зарезервированных имен, нет таких ограничений


Проверка существования свойства,
при помощи оператора in

для перебора всех свойст объекта используется 
цикл for...in
синтаксис:

for (let key in имя_объекта) {
	// тело цикла
}

key - переменная цикла for...in

упорядочение свойств объекта:

если имена ключей свойств
это целочисленные значение
то они выводятся в порядке возрастания
остальные типы значений сортируются в порядке создания

Целочисленное значение - значение которое может быть
преобразованно в целое число из строки
и в строку из числа без измений



Объекты хранятся и копируются по ссылке
а примитивные значение: строки, числа, логические значения и т.д.
копируются "как целое значение"

переменная которой присвоен объект, хранит не сам объект
, а его адрес в памяти , другими словами, хранит в себе
"ссылку" на объект

при копировании переменной объекта копируется ссылка,
но сам объект не дублируется
по такой ссылке можно получать доступ к объекту,
получать данные объекта и изменять данные объекта

Сравнение объектов по ссылке
два объекта равны только в том случае
если это ссылки на один и тот же объект

и если две переменные ссылкаются на похожие объекты
то эти объекты(переменные-ссылки) не будут равны


для сравнений типа obj1>obj2, или obj == 5
объекты преобразуются в примитивы


клонирование и объединение Object.assign


ссылки на похожие переменные не равны, но
можно создать копию-клон объекта
для этого порядок действий:
1) создать новый пустой объект
2) вопроизвести структуру сущетсвующего объекта
3) перебрав свойсва существующего объекта

есть специальный метод Object.assign
синтаксис Object.assign:
Object.assign(имя_объекта_в_который_копируют, имя_объекта_из_которого_копируют)
данный метод копирует свойства всех объектов через запятую в первый указанный объект,
свойства всех аргументов начиная со второго, копируются в первый объект
возвращается первый указаный объект

Вложенные свойства объекта
let user = {
	name: "john",
	parameters: {
		height: 160,
		weight: 100,
	}
}
alert(user.parameters.height);

Копирование вложенных свойств объекта

чтобы избежать ситуации когда клонируется ссылка на под объект
а не копируется сам подобъект, нужно использовать алгоритм "глубокого клонирования"
допустим _.cloneDeep(obj) из библиотеки lodash
или глобальный метод structuredClone(),
этот глобальный мето делает полную копию объекта

Сборка мусора
принцип достижимости
достижимость - значения доступны или используются
Базовое Множество достижимых значений - корни
Взаимосвязанный объекты: семья

только входящие ссылки делают объект достижимым

основной алгорит сборки мусора - алгоритм пометок

Методы объекты, "this"
примеры методов
метод - действия представулены функциями в свойствах объекта
Метод - функция, которая является свойством объекта

Сокрщённая запись метода:
полный вид записи метода:
user = {
	sayHi: function() {
	alert("Привет");
	},
};
сокращенный вид записи метода:
user = {
	sayHi() {
	alert("Привет");
	},
};

Ключевое слово "this" в методах
для доступа к информации внутри объекта метод
может использовать ключевое слово "this":
let user = {
	name: "John",
	age: 30,
	sayHi = function(message) {
		alert(message + `${this.user}`)
	},
};

alert("привет, ");

Ключевое слово "this" не является фиксированным
"this" можно использовать в любой функции, даже если это метод объекта
значение "this" вычисляется во время выполнения кода, в завиисмости от контекста

у стрелочных функций нет "this"



******
для решения задачи номер 3
надо вынести функции из объекта
отдельные маленкие фукнции ап и давн


Конструктор , оператор "new"

функция конструктор:
1) имя функции конструктора начинается с большой буквы
2) функция-конструктор должна выполняться только при помощи оператора new
синтаксис:
function Имя_Объекта(переменная) {
	this.имя_св-ва1_объекта = значение_св-ва1;
	this.имя_св-ва2_объекта = значение_св-ва2;
}
чтобы вызвать функцию-конструктор
let имя_внешней_переменной = new Имя_Объекта(переменная); //присваивание св-в объекта переменной
alert(имя_внешней_переменной.имя_св-ва1_объекта);

любая функция кроме стрелочной(потому что не может использовать this)
может использоваться в качестве конструктора
конструктор запускается ключевым словом new



Проверка на вызов в режиме конструктора: new.target
function User(){
	alert(new.target);
}
new User();


Возврат значения из конструктора return
если в записи конструктора есть оператор return, то:
1) при вызове return с объектом, вместо this вернется объект
2) при вызове return с примитивным значением, оно проигнориуется
пример:
function BigUser() {
	this.name = "John";
	return { name: "Godzilla"};
};
alert( new BigUser().name);



Создание методов в конструкторе:


Опциональная цепочка "?." 
"?." это безопасный способ доступа к свойствам вложенных объектов,
даже если какое либо из промежуточныъ свойств не существует

проблема "несущестсвущего свойства"
бывает что пользователь не указал значение для свойства в объекте
и при запросе данныъх из такого свойства мы не можем знать есть ли
значение или нет значение в свойстве

чтобы этого избежать нужно проверять свойство оператором "?"
прежде чем обращаться к свойству объекта
но при такой записи повторяются участки кода, поэтому
ввели особое обозначение , опциональная цепочка "?."
данный оператор ставится вместо точки между именем объекта и именем свойтсва


Опциональная цепочка "?." останавливает вычисление  и возвращает undefined, если значение перед ?.
равно undefined или null

value?.prop :
1)работает как value.prop если значение value существует
2)в противном случае(когда value равно undefined/null) он возвращает undefined

оператор опциональной цепочки ?. можно только там где нормально, что чего-то нет
переменная перед оператором ?. должна быть объявлена

сокращенное вычисление
оператор ?. многовенно останавливает выисление, если слева чего-либо не сущетввует
так что если после ?. есть какие либо ф-ции или операции, то они не произойдут

другие варианты применения синтаксической конструкции ?.

?.()
опциональную цепочку можно использовать для вызова функции которая не сущетсвует
пример:

let userAdmin = {
	admin() {
	alert("я админ!"):
	};
};

let userGuest = {};

userAdmin.admin?.();
userGuest.admin?.();

Синтаксис  ?.[] позволяет безопасно считывать свойства из объекта,
объекта который может не сущетсвовать

let key = "firstName";

let user1 = {
	firstName: "John",
};
let user2 = null;


alert(user1?.[key]);
alert(user2?.[key]);


синтаксическая конструкция ?. используется для безопасного чтения или удаления,
но не для записи данных

итого, синтаксис опциональной цепочки  ?. имеет три формы:
1) obj?.prop - возвращает obj.prop если obj существует, в противном случае undefined
2) obj?.[prop] - возвращает obj.[prop] если obj существует, в противном случае undefined
3) obj.method?.() - вызывает obj.method.(), если  obj.method существует, в противном случае возвращает undefined



тип данных Symbol
символ это тип данных использующихся для внесения значений в свойства объекта

символы это уникальные идентификаторы 
создаются с помощью функции Symbol():
let id = Symbol();
при создании можно дать описание(имя) символу
let id = Symbol("имя_символа");
описание(имя) - это просто метка, которая ни на что не виляет
даже множетство символов с одинаковым описанием(именем) Гарантировано Уникальны!
есть специальная команда .description
let id = Symbol("opisania");
alert(id.description);
"Скрытые свойства"
символы позволяют создавать скрытые свойства для объектов
к таким свойствам нельзя случайно обратиться и переписать эти свойства из других
частей программы
пример:
let user = {
	name:"Вася",
};

let id = Symbol("id");

user[id] = 1;

alert(user[id]);

символы в литеральном объекте обозначают в квадратны скобкаъ:
пример:
let id1 = Symbol("id");
let user = {
	name: "вася",
	[id1]: 1223,
};

символы игнорируются циклом for... in
а вот Object.assign копирует и строковые, и символьные свойства

Действует Принцип Сокрытия Символьных Свойств

глобальные символы
существует Глобальные Реестр Символов
синтаксис: Symbol.for("name")

let id = Symbol.for("id");
let idAgain = Symbol.for("id");
alert(id === idAgain); //true

Symbol.keyFor
кроме Symbol.for(key) сущетсвует обратный метод Symbol.keyFor(sum)
этот мтеод принимает глобальный символ и возвращает его имя
пример:
let sum = Symbol.for("name");
let sum2 = Symbol.for("id");

alert(Symbol.keyFor(sum));
alert(Symbol.keyFor(sum2));


сущетсвуют Системные Символы
используются, для того чтобы настраивать различные аспекты поведения объектов 
примеры:
Symbol.hasInstance
Symbol.isConcatSpreadable
Symbol.iterator
Symbol.toPrimitive


к примеру Symbol.toPrimitive позволяет описать правила объекта,
согласно которым он будет преоброзовываться к примитиву



Преобразование в примитивы
в случае операций сложения , вычитания или строковыъ операций
объекты автоматически преобразуются в примитивы
затем выполняется сама операция над полученными прмитивами
на выходе получается примитивное значение
результат математическое операции над двумя объектами не может быть объект,
это будет примитив

Правила преобразования:
1 не существуу4ет Логического преобразования, все объекты true
2 Числовое преобразование обхектов проиходит когда происходит вычитание объектов
или применяются математиче6кие ф-ции
3 преобразования к Строке, происходит когда на экран выводится объект посредством
alert(obj)


Хинты:
"string":
выполняем операция над объектом которая ожидает строку
например alert()
"number":
преобразует объект к числу в случае математических операций
"default"
проиходит редко, когда оператор не уверен какой тип ожидать
например бинарный плюс

чтобы выполнить преобразование js пытается найти и вызвать три следующиъ метода:
1 вызвать obj[Symbol.toPrimitive(hint)] -метод с символьным ключом Symbol.toPrimitive
(системный символ), если такой метод существует
2 "string" попробовать вызвать obj.toSring() или obj.valueOf()
смотря какой сущетсвует
3 иначе "number" или "default"
попробовать ызвать obj.valueOf() или obj.toString()


Symbol.toPrimitive
используется так:
obj[Symbol.toPrimitive] = function(hint) {
	
}









добавить конструкцию if
добавить ключевое слово include
добавить ключевое слово key





Метод - это функция в свойствах объекта
МЕТОДЫ ОБЪЕКТА
*/




function CreateUser1() {
	function User(name) {
  	this.name = name;
  	this.isAdmin = false;
	};

let user = new User("peter");

document.cookie = document.cookie + user.name; // peter
};



function CreateUser2() {
	function User(name) {
  	this.name = name;
  	this.isAdmin = false;
	};

let user = new User("john");

document.cookie = document.cookie + user.name; // john
};




function Alert() {
	alert(document.cookie); // показываем все куки
};

/*



const omit = (obj, ...fields) => {
  const newObj = {...obj};
  for (const fieldsElement of fields) {
     delete newObj[fieldsElement];
  };
  return newObj;
};




const fruits = {
 apple: 2,
 orange: 4,
 banana: 3
};

console.log(omit(fruits, 'apple', 'banana')); // { apple: 2, banana: 3 }






const omit = (obj, ...fields) => {
  const newObj = {};
  for (const fieldsElement of Object.entries(obj)) {
  	if(!fieldsElement.includes(key)) {
     newObj[key] = value;
  	};
  };
  return newObj;
};


let a = sortStrings(['b', 'a', 'c'], 'asc'); 
console.log(a)
a = sortStrings(['b', 'a', 'c'], 'desc'); 
console.log(a)
a = sortStrings(['абрикос', 'Абрикос', 'яблоко', 'Яблоко', 'ёжик', 'Ёжик'], 'asc'); 
console.log(a)




function sortAsc(a1, b1) {
	return a1.localeCompare(b1, ["ru-RU", "en-EN"], {caseFirst: 'upper'});
};

function sortDesc(b2, a2) {
	return b2.localeCompare(a2, ["ru-RU", "en-EN"], {caseFirst: 'upper'});
};

const sortAsc

function sortStrings(arr, param = "asc") {
    return [...arr].sort((a, b) => (param === 'asc'? sortAsc(a, b): sortDesc(b, a)));
};





let id = Symbol("id");
let user  = {};
alert(user?.address?.street);

function User(name) {
	this.name = name;

	this.sayHi = function() {
		alert("my name is " + this.name);
	};
}

let john = new User("John");

john.sayHi();




function BigUser() {
	this.name = "John";
	return;
}

alert(new BigUser().name);
function BigUser() {
	this.name = "John";
	return {name :"Dog"};
}

alert(new BigUser().name);


function User(name) {
	this.name = name;
	this.isAdmin = false;
}

let user = new User("Jack");
// user = {
// name: "Jack",
// isAdmin: false,
// };

alert(user.name);
alert(user.isAdmin);



let user = {
	name: "John",
	age: 30,
	sayHi: function() {
		alert(`hello! My name is ${this.name}`);
	},
};
user.name = prompt("Enter the name: ","");
user.sayHi();








function makeUser(name, age) {
	return {
		name,
		age,
	};
};

let user = makeUser("Asher", 12);
alert(user.name)





























const user = {
	"имя": "Иван",
	"фамилия": "Петров",
	"возраст": "13 лет",
	"место рождения": "город Москва",
};
let info;
info = prompt("Что вы хотите узнать о пользователе?","");
alert(user[info]);






const omit = (obj, ...fields) => {
  const newObj = {};
  Object.entries(obj).forEach(([key, value]) => {
    if (!fields.includes(key)) {
      newObj[key] = value;
    }
  });
  return newObj;
};

const fruits = {
 apple: 2,
 orange: 4,
 banana: 3
};

console.log(omit(fruits, 'apple', 'banana')); // Вернет объект - { orange: 4 }

const pick = (obj, ...fields) => {
  let newObj = {};
  for (const fieldsArrElement of fields) {
    if (fieldsArrElement in obj) {
      newObj[`${fieldsArrElement}`] = obj[fieldsArrElement];
    }
  }
  return newObj;
};






const fruits = {
 apple: 2,
 orange: 4,
 banana: 3
};

console.log(pick(fruits, 'orange', 'banana')); // { apple: 2, banana: 3 }










let a = sortStrings(['b', 'a', 'c'], 'asc'); 
console.log(a)
a = sortStrings(['b', 'a', 'c'], 'desc'); 
console.log(a)
a = sortStrings(['абрикос', 'Абрикос', 'яблоко', 'Яблоко', 'ёжик', 'Ёжик'], 'asc'); 
console.log(a)








function sortStrings(arr, param = "asc") {
    const newArr = [...arr];
    return newArr.sort((a, b) => {
      if (param === 'asc') {
        return a.localeCompare(b, ["ru-RU", "en-EN"], {caseFirst: 'upper'});
      }
       else if (param === 'desc') {
        return b.localeCompare(a, ["ru-RU", "en-EN"], {caseFirst: 'upper'});
      };
    });
  };




let user = {
	name:"Вася",
};

let id = Symbol("id");

user[id] = 1;

alert(user[id]);



let id = Symbol("opisania");
alert(id.description);




let key = "firstName";

let user1 = {
	firstName: "John",
};
let user2 = null;


alert(user1?.[key]);
alert(user2?.[key]);




let userAdmin = {
	admin() {
	alert("я админ!");
	},
};

let userGuest = {};

userAdmin.admin?.();
userGuest.admin?.();




let users_data = {
	user1: {
		street: "main st.",
	},
	user2: {
		street: "",
	},

};
let user2 = {};

alert(users_data.user1.street);
alert(user2?.user2?.street);








//Accumulator
function Accumulator(startingValue) {
	this.value = startingValue;
	this.read = function () {
		this.calculation = +prompt("Введите значение","");
		this.value = this.calculation + this.value;
		return;
	}
}
let accumulator = new Accumulator(1);
accumulator.read(); // прибавляет введённое пользователем значение к текущему значению
accumulator.read(); // прибавляет введённое пользователем значение к текущему значению

alert(accumulator.value); // выведет сумму этих значений









function Calculator()  {
	this.read = function() {
		this.number1 = +prompt("Введите первое значение:","");
		this.number2 = +prompt("Введите второе значение:","");
	};
	this.sum = function() {
	let suma = this.number1 + this.number2;
	return suma;
	};
	this.mul = function() {
		let mula = this.number1*this.number2;
		return mula;
	};
};

let kalkulator = new Calculator();

kalkulator.read();
alert(`Сумма числе равна: ${kalkulator.sum()}`);
alert(`Произведение чисел равно: ${kalkulator.mul()}`);





let calculator = {
	number1: "",
	number2: "",
	read: function() {
		this.number1 = +prompt("Введите первое значение:","");
		this.number2 = +prompt("Введите второе значение:","");
		//calculator.number1 = number01;
		//calculator.number2 = number02;
	},
	sum: function() {
		let suma = this.number1 + this.number2;
		return suma;
	},
	mul: function() {
		let mula = this.number1*this.number2;
		return mula;
	},
};


calculator.read();
alert(`Сумма числе равна: ${calculator.sum()}`);
alert(`Произведение чисел равно: ${calculator.mul()}`);












let obj = {};
function A() {
	return obj;
};
function B() {
	return obj;
};

let a = new A();
let b = new B();


alert(a);
alert(b);
alert( a == b ); // true
function User(name) {
	this.username = name;
	this.sayHi = function() {
		alert(`Hello,  ${this.username}`);
	}
};

let peter = new User("Peter");
peter.sayHi();

function BigUser() {
	this.name = "John";
	return { name: "Godzilla"};
};
alert( new BigUser().name);


function User(name) {  //декларация ф-ции
	this.username = name;
	this.isAdmin = false;
}

let user1 = new User("Jack");
let user2 = new User("Anna");

alert(`User1 name is: ${user1.username}, User1 acces level is: ${user1.isAdmin}`);
alert(`User2 name is: ${user2.username}, User2 acces level is: ${user2.isAdmin}`);
let ladder = {
  step: 0,
  up: function() {
    this.step++;
    return this;
  },
  down: function () {
    this.step--;
    return this;
  },
  showStep: function() { // показывает текущую ступеньку
    alert( this.step );
    return this;
  },
};








ladder.up().up().down().showStep().down().showStep(); // показывает 1 затем 0







function makeUser() {
	return {
		name: "John",
		ref: function() {
			return this;
		},
	};
};
let user = makeUser();
alert(user.ref().name);


let user = {
	firstName: "Ilya",
	sayHi() {
		let arrow = () => alert(this.firstName);
		arrow();
	},
};

user.sayHi();


function sayHi() {
	alert(this);
};// вызов функции с ключевым словом "this" без объекта

sayHi();

let user = {
	name: "John",
};
let admin = {
	name: "Admin",
};

sayHi = function() {
	alert(this.name);
};

user.f = sayHi;
admin.f = sayHi;

user.f();
admin.f();

admin['f']();




let user;
user = {
	name: "",
	age: 30,
	sayHi: function(message) {
		alert(message + `${this.name}`); // ключевое слов this - этот именно этот объект, 
										//this - текущий объект
										//user.name - в данном случае это внешняя ссылка на свойство 
	},
};

user.name = prompt("Введите ваше имя: ","");
user.sayHi("Привет, ");


let user = {
	name: "John",
	age: 30,
	sayHi: function(message) {
		alert(message);
	},
};



user.sayHi("oeunhoneu");

user.sayHi = function(message) {
	alert(message);
};

function marry(man, woman) {
	woman.husband = man;
	man.wife = woman;

	return {
		father: man,
		mother: woman,
	}
};

let family = marry ({
	name: "John"
}, {
	name: "Ann"
},);
delete family.father;
delete family.mother.husband;
alert(family.father.name);




let user = {
	name: "john",
	sizes: {
		height: 189,
		weight: 40,
	}
};

let clone = {};
clone = structuredClone(user);
//  в таком случае у объекта clone и объекта user
// будет ссылка на один общий под объект sizes
user.sizes.height = 999;
alert(clone.sizes.height);





let user = {
	name: "john",
	age: 12,
};
let permition1 = { canView: true,};
let permition2 = { canEdit: true,};
let clone = {};

Object.assign(clone, user, permition1, permition2);
for (let key in clone) {
	alert(`${key} ${clone[key]}`);
}

let user = {
	name: "John",
	age: 30,
};
let clone = {};
Object.assign(clone, user);
alert(clone.name);


let user = {
	name: "John",
	age: 30,
};

let clone = {

};
alert(clone);

for(let key in user) {
	clone[key] = user[key];	
};

alert(clone.name);

let user = {
	name: John;
}

let admin = user; //копируется ссылка



let menu = {
	width: 200,
	height: 300,
	title: "My menu",
};

multyplyNumeric(menu);

alert(menu);


function multyplyNumeric(obj) {
	for (let key in obj) {
		if (typeof obj[key] == "number") {
			alert("значение свойство Целочисленное");
			obj[key] = obj[key]*2;
			alert(obj[key]);
			}
		else {
			alert("значение свойства не Целочисленное");
			};
	};
};



let sum;
let salaries = {
	John: 1000,
	Ann: 10,
	Pete: 1000,
}
sum = (salaries.John + salaries.Ann + salaries.Pete);
alert(sum);





let keys;
let object_1 = {
	valueData_1: "1",
};

function isEmpty(obj) {
	for (let key in object_1) {
		keys = key;
	};

	if(keys) {
		alert("объект полный");
	} 
	else {
		alert("объект пустой");
	}
};


isEmpty(object_1);







let user = {
	name: "John",
	surname: "Smith",
};

alert(user.name);
user.name = "Pete";
alert(user.name);
delete user.name;
alert(user.name);


let order = {
	"3": "value3",
	"5": "value5",
	"1": "value1",
	"4": "value4",
	"2": "value2",
}

for(let key in order) {
	alert(key);
};



let login = {
	user_name: "Admin",
	password: "Qwerty1",
}

for(let key in login) {
	if (login[key] == "Qwerty1") {
		alert("login succes");
	}
}








let user = {
	name: "john",
	age: 30,
	isAdmin: true,
};

for (let key in user) {
	alert(key);
	alert(user[key]);
};





let girls_data = {
	eye_color: "green",
	height: "tall",
}

alert("weight" in girls_data);
alert("eye_color" in girls_data);



function makeUser(name, password) {
	return {
		name,
		password,
	}
}


name = prompt("vvedi login: ","");
password = prompt("vvedio parol: ","");
let user = makeUser(name, password);
alert(`ваш логин: ${user.name} ваш пароль: ${user.password}`)







let username;
let password;
username = prompt("Введите ваш логин: ","");
password = prompt("Введите ваш пароль: ","");

let login = {
	[password] : `Добро пожаловать на сайт, ${username}!`,
};
alert(login.Qwerty1);



let user_data = {
	name: "Ashley",
	age: 33,
	gender: "female",
	"eye color": "green",
	height: "180cm",
}
let key = prompt("What you want Know about Ashley?","");
alert(user_data[key]);




let data_base = {
	greeting: "Welcome to site",
	'user name': "anonymos_user!",
	dots: " , ",
}

data_base.dots = prompt("vvedio znaki","");
alert(data_base.greeting + data_base.dots + data_base['user name']);


function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}
ask(
  "Вы согласны?",
  ()=> alert("Вы согласились."),
  ()=> alert("Вы отменили выполнение."));

let sum = (a, b) => {
	let result = a + b;
	return result; // обязательная директива return
};

alert(sum(1,2)); //3




let sum = (a, b) => a+b;



alert(sum(2,2));
sayHi("vasya");

let sayHi = function(name) {
	alert(`priven ${name}`);
}



function ask(question, yes, no) {
	if(confirm(question)) yes()
		else no();
}


ask(
	"вы согласны?",
	function() {alert("вы согласились.");}, //анонимные функции
	function() {alert("вы отменили выполнение");} //анонимные функции
);

function ask(question, yes, no) {
	if (confirm(question)) yes()
	else no();
}

function showOk() {
	alert("вы согласы");
}

function showCancel() {
	alert("вы отменили выполнение");
}

ask("вы согласны?", showOk, showCancel);







let ask;
ask = function(question, yes, no) {
	let q = confirm(question);
	if (q) {
		yes(); // функция коллбек 
	} 
	else {
		no(); // функция коллбек
	}
	function yes() {
		alert(yes_text);
	}
	function no() {
		alert(no_text);
	}
};

let q_text;
let yes_text;
let no_text;
q_text = prompt("Введите текст вопроса:","");
yes_text = prompt("Введите текст на положительный ответ:","");
no_text = prompt("Введите текст на отрицательный ответ:","");
ask(q_text,yes_text,no_text);


let sayHi;
sayHi = function(x) {
	alert("func expression helloworld " + x);
};

let func;
func = sayHi;
func(1);


function sayHi(x) {
	alert("hello world " + x);
}


let func = sayHi;

func(1);




function pow(x, n) {
	return x**n;
}

alert( pow(1, 100));



function min(x, y) {
	if (x<y) {
		return x;
	}
	else if(y<x) {
		return y;
	}
	else if(x=y) {
		return x;
	}
}


alert(min(1, 1));

let i;
i = "hello";
function shMessage(text="значение по умолчанию") {  //локальная перменная функции text
	alert(text);
}
shMessage();



let message;
message = "external message";
function showMessage() {
	message ="internal message";
	alert(message);
}


showMessage();
let message;
message = "external message";
function showMessage() {
	let message ="internal message";
	alert(message);
}


showMessage();
alert(message);

let x;
let y;
i=2;
j=2;
function instrument(x, y) {
	alert(x+y);
}

instrument(i, j);

const number = +prompt("Введите число между 0 и 3","");

switch(number) {
	case 0:
	 alert("вы ввели число 0");
	 break;
	case 1:
	 alert("вы ввели число 1");
	 break;
	case 2:
	case 3:
	 alert("вы ввели число 2 или число 3");
	break;
}

let browseVersion;
browseVersion = prompt("Введите версию вашего браузера:","неопознаный браузер");
if(browseVersion == "Edge") {
	    alert( `Ваш ответ - ${browseVersion}, мы поддерживаем браузер Эдж!` );
}
else if(browseVersion == ("Chrome"||"Firefox"||"Safari"||"Opera")) {
    alert( `Ваш ответ - ${browseVersion}, мы поддерживаем и этот браузер тоже` );
}
else {
	    alert( `Ваш ответ - ${browseVersion}, к сожалению, мы не поддерживаем этот браузер` );
}




let number;
number = +prompt("Введите число до 10!","");
if ((number < 10) && (number > 0) ) {
	switch(number) {
	case 2:
	case 3:
	case 5:
	case 7:
	alert(`${number}, является простым числом!`);
	break;
	default:
	alert(`${number}, не является простым числом!`);
	break;
    }
}
else {
	alert("ошибка ввода!");
}




let sum;
sum = +prompt("какую оценку выхотите?","");
switch(sum) {
	case 1:
		alert(`Очень плохо! ${sum}`);
		break;
	case 2:
		alert(`Плохо! ${sum}`);
		break;
	case 3:
		alert(`Удовлетворительно! ${sum}`);
		break;
	case 4:
		alert(`Нормально! ${sum}`);
		break;
	case 5:
		alert(`Отлично! ${sum}`);
		break;
	default:
		alert(`Это не оценка! ${sum}`);
}

start:for(let number = 2; number < 10; number++) {
	for(let divider = 2; divider < number; divider++) {
		if (number % divider == 0) continue start;
	}
		alert(number);		
		
}


должно быть две увеличивающиесю переменные инкрементом
Переписать в фор скрипт
let begin;
let number;
begin = 2;
number = 2;
do {
	alert(number);
	if (((number%number)==1) && ((number%1)==number)) {
		++number;
	} 

}
потом переписать условие
(number%2==0)
while ( number < 10);


let i;
do {
	i = prompt("Введите число большее 100!","");
	if( i > 100) {
		alert(i);
	}
	else if (i == null){
		break;
	}
	else continue;
}
while (i<100)

let i;
i = 0;
while ( i < 3) {
	alert(`number ${i}!`);
	i++;
}



for ( let i = 0; i < 3; i++) {
	alert(`number ${i}!`);
}


for(let i = 0; i <= 10; ++i) {
	if (i % 2 == 0) {
		alert(i);
	}
	else continue;
}

outer: for(let i = 0;i < 3; i++) {
	for(let j = 0;j < 3; j++){
		input =  prompt(`Значение на координатах (${i},${j})`,"")
		if(!input) {
			break outer;
		}
	}
}
alert("Готово!");


let i;
i = 0;
for(;i < 10; i++) {
	if(i % 2 == 0) {
		continue;
	}
	alert(i);
}


let sum;
let value;
sum = 0;

while(true) {
	value = +prompt("Введите число: ","");
	if (!value) {
		break;
	}
	sum += value;
}
alert("Сумма " + sum);










let i;
i = 0;
for (; i < 3;) {
	alert(i++);
}



let i;
i = 0;
for (; i < 3; i++) {
	alert(i);
}



"use strict";
for( let i = 0; i < 3; i++) {
	alert(i);
}




let i = 0;
do {
	alert(i);
	i++;
} while(i<3);

let i = 3;
while(i) {
	alert(i);
	i--;
}




let i = 0;
while (i<3) {
	alert(i);
	i++;
}




let i = 0;
while (i<3) {
	alert(i);
	i++;
}

let username;
username = prompt("Введите ваше имя:","");
alert((username)??( "Привет, Анонимус!"));






let accesAllowed;
let age;

age = prompt("Введите ваш возраст: ","ваш возраст");

if(age>=18) {
	accesAllowed = true;
}
else {
	accesAllowed = false;
}

alert(accesAllowed);*/

/*
ТЕРНАРНЫЙ ЗНАК ВОПРОСА
? имеет три аргумента
let result = условие?значение1:значение2;

*//*
let accesAllowed;
let age;
age = prompt("Введите ваш возраст: ","ваш возраст");
accesAllowed = (age>=18)?true:false;

alert(accesAllowed); 



*//*
if(0) {
	
}
else {
	alert("в этом коде всегда будет ложен аргумент if()")
}





let year;
year = prompt("В каком году вышла спецификация ECMA-2015","год выхода");
if (year == 2015) {
	alert(`Верно! спецификация вышла в ${year} году`);
} 
else {
	alert(`Неверно! спецификация вышла не в ${year} году`);
}




//let a = 0;
//a = Boolean(a);
//alert(a); // false

//let b = "0";
//b = Boolean(b);
//alert(b);  //true

//alert(a == b); // true!


/*
alert(1 > false);




alert("б">"а");
alert("бв">"ба");
alert("бв">"бб");


alert(2>1);
alert(2==1);
alert(2!=1);

let result;
result = 2 < 1;
alert(result);


*/






/*

let counter_a;
let counter_b;
let counter_c;
let counter_sum;
counter_a = 1;
counter_b = 2;
counter_c = 3;
counter_sum = (counter_b += counter_a, counter_c += counter_b);
alert(`сумма переменных A, B, C равна: ${counter_sum}`);
*/
/*
let a = prompt("Первое число?", 1);
let b = prompt("Второе число?", 2);

a = Number(a);
b = Number(b);
alert(`сумма первого и второго числа равна: ${a + b}`); // 12
*/

/*
let counter;
counter = 1;
counter++;
alert(counter);
*/
/*
let counter;
counter = 1;
alert(counter--);
*/

/*
let shortValue;
shortValue = 2;
shortValue = shortValue + 1;
alert(shortValue);
shortValue = shortValue * 2;
alert(shortValue);
*/

// сокращенный пример
/*let shortValue;
shortValue = 2;
shortValue += 1;
alert(shortValue);
shortValue *= 2;
alert(shortValue);


let shortValue;
shortValue = 2;
shortValue *= 2 + 5;
alert(shortValue);
*/





//let valueData = 1 + 2 * 3;
//alert(valueData);
/*
let valueData_1;
let valueData_2;
let valueData_3;

valueData_1 = 1;
valueData_2 = 2;

valueData_3 = 3 - (valueData_1 =  valueData_2 + 1);
alert(valueData_1);
alert(valueData_3);
*/
/*
let valueData_a;
let valueData_b;
let valueData_c;

valueData_a = valueData_b = valueData_c = 10 + 10;
alert(`Переменная А равна: ${valueData_a}`);
alert(`Переменная Б равна: ${valueData_b}`);
alert(`Переменная Ц равна: ${valueData_c}`);
*/


/*
*/




// ТИПЫ ДАННЫХ
// ПЕРЕМЕННЫХ ДИНАМИЧЕСКИ ТИПИЗИРОВАНЫ
// ПЕРЕМЕННЫЕ МОГУТ ПОЛУЧАТЬ ЛЮБОЙ ТИП ДАННЫХ

 // В ИМЕНАХ ПЕРЕМЕННЫХ РЕГИСТР ИМЕЕТ ЗНАЧЕНИЕ
 // ИМЕНА КОНСТАНТЫ ЗАПИСЫВАЮТСЯ КАПСОМ ЕСЛИ ЭТО ЖЕСТКО ЗАПРОГРАМИРОВАННОЕ ЗНАЧЕНИЕ
 // ИЗВЕНСТНОЕ ИЗНАЧАЛЬНО

 // ЕСЛИ ЗНАЧЕНИЕ КОНСТАНЫ СТАНОВИТСЯ ИЗВЕСТНЫМ ПРИ ВЫЧИСЛЕНИИ СКРИПТА
 // ТО ТАКАЯ КОНСТАНТА ЗАПИСЫВАЕТСЯ ВЕРЛЮЖЕЙ НОТАЦИЕЙ



/*
константе надо сразу присваивать значение 
const helloMessage = "hello world!";

переменной можно присвоить значение потом:
let helloMessage;
helloMessage = "hello world!";






"use strict";  директива - код работает в современном режиме - строгий режим
alert("hello");
alert("world");


однострочный комментарий 'Ctrl + /'


многострочный 
	комментарий
	'Ctrl + Shift + /'
*/